# This is the repository that used to summary C knowledge 

## 引用和指针的区别
- 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
- 引用初始化后不能被改变，指针可以改变所指的对象。
- 不存在指向空值的引用，但是存在指向空值的指针

## 堆栈的溢出
- 函数调用层次太多
- 数组的越界访问
- 申请内存没有释放
- 非法地址

## 函数进栈调用过程
压栈函数返回地址，开辟新的桢栈。函数完成后

## 字节对齐
理论上讲计算机的最小单位是字节，但是计算机并非是逐字节读取的信息。而是以2,4,8 的倍数进行读取的因此需要字节对齐。
- 结构体变量的首地址能够被其对齐字节数大小所整除。
- 结构体每个成员相对结构体首地址的偏移都是成员大小的整数倍，如不满足，对前一个成员填充字节以满足。
- 结构体的总大小为结构体对最大成员大小的整数倍

一个字节对齐: **program pack(1)** 可以使其一个直接对齐。

## 函数指针和指针函数的区别
- 指针函数本质上是一个函数，返回值是指针。
- 函数指针本质上是一个指针，指向函数。 

## 什么是预编译
预先做一些文本的工作。比如#define， #ifdef 条件编译等
- 总是使用不经常改动的大型代码体。
- 程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。
## 怎么防止文件被重复编译
- program once
- 条件编译

## STM32 中断
处理器自动保存现场到堆栈里

- {PC, xPSR, R0-R3, R12, LR}

- 一旦入栈结束，ISR便可开始执行

- 晚到的中断会重新取ISR地址，但无需再次保存现场

- 退出中断：

- 中断前的现场被自动从堆栈中恢复

- 一旦出栈完成，继续执行被中断打断的指令

- 出栈的过程也可被打断，使得随时可以响应新的中断，而不再进行现场保存
